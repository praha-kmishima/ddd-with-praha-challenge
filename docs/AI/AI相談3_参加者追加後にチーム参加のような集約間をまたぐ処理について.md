## 質問

```
このドメインモデル図は、TeamとParticipantの集約が離れていますが、
たとえば、Participantを追加した後、チームに所属させる場合は、異なる集約間ですが問題ないのでしょうか？
```

## 解答

<think>質問者は異なる集約（TeamとParticipant）間での操作について質問しています。具体的には、Participantを新規作成した後に、そのParticipantをTeamに所属させる場合に、異なる集約間での操作が問題ないかどうかを問うています。

これはドメイン駆動設計（DDD）における重要な疑問です。異なる集約間での操作は一般的に以下のような点を考慮する必要があります：

1. **トランザクショナル整合性**: 異なる集約は独立してトランザクション境界を持つべきとされています。厳密なDDDでは、1つのトランザクションで複数の集約を更新することは避けるべきとされています。

2. **集約間の参照**: 集約間は通常IDによる参照（外部キー的な関係）で行われるべきです。ドメインモデル図ではTeamがParticipantIdのリストを持っているのでこの原則に従っています。

3. **集約間の操作順序**: 複数の集約に影響を与える操作は、アプリケーションサービスレベルで順序付けして行う必要があります。

質問に対する回答としては、異なる集約間の操作は問題ありませんが、適切な方法で行う必要があることを説明すべきです。以下のポイントを含めましょう：

- 異なる集約間の操作はアプリケーションサービスの責務である
- Participantの追加とチームへの所属は2つの独立した操作として実行すべき
- トランザクショナル整合性を厳密に保つなら、これらは別々のトランザクションとなる（結果整合性を許容）
- イベント駆動アプローチを使うこともできる（例：「ParticipantCreated」イベントを発行し、それをTeam集約が処理する）

これらの点を踏まえて回答します。</think># 異なる集約間の操作について

ご質問いただいた点は、ドメイン駆動設計（DDD）における重要な考慮事項です。TeamとParticipantが別々の集約として設計されている中で、Participantを作成した後にTeamに所属させる操作が問題ないかというご質問ですね。

## 異なる集約間の操作は問題ないですが、適切な実装が必要です

結論から言うと、異なる集約間の操作は問題ありませんが、いくつかの原則に従って実装する必要があります：

1. **アプリケーションサービスによる調整**
   - 異なる集約間の操作はアプリケーションサービス層で調整します
   - 例：`ParticipantService`でParticipantを作成し、`TeamService`でチームへの参加を処理

2. **IDによる参照**
   - 図を見ると、Teamは`members: List~ParticipantId~`としてParticipantを参照しています
   - これはDDDの原則に従った適切な設計です（ID参照による集約間の疎結合）

3. **トランザクション境界の考慮**
   - 厳密なDDDでは、各集約は独立したトランザクション境界を持つべきです
   - 実装例：
     ```
     // 疑似コード
     transaction1 {
       participant = participantRepository.create(new Participant(...));
     }
     
     transaction2 {
       team = teamRepository.findById(teamId);
       team.addMember(participant.id);
       teamRepository.save(team);
     }
     ```

4. **結果整合性の許容**
   - 異なるトランザクションで実行する場合、一時的な不整合状態が生じる可能性があります
   - 例えば、Participantは作成されたがTeamへの追加が失敗した場合

5. **イベント駆動アプローチ**
   - より洗練された方法として、イベント駆動アーキテクチャを採用できます
   - 例：`ParticipantCreated`イベントを発行し、適切なハンドラでTeamへの追加処理を行う

## 現実的な実装の選択肢

実際のアプリケーションでは、次のいずれかのアプローチを選ぶことが多いです：

1. **単一トランザクションでの実装（シンプルさ優先）**
   - 小〜中規模システムでよく使われるアプローチ
   - トレードオフ：DDDの厳密な原則からは外れるが、実装がシンプル

2. **結果整合性を許容した複数トランザクション**
   - より厳密なDDDの原則に従う
   - 一時的な不整合状態のハンドリングが必要

3. **Saga/プロセスマネージャパターン**
   - 複雑なユースケースのための長期トランザクション
   - 失敗した場合の補償トランザクションが必要

どのアプローチを選択するかは、ビジネス要件とシステムの複雑さによって決まります。

## 質問

```
なるほど。
では、participantが休会または退会になると、おそらく自動的にチームから離脱してしまうと思うのですが、
こういった場合、1つのトランザクションで、複数集約が同時に状態変更されるべきなのでしょうか
```

## 解答

<think>この質問は集約間の整合性を維持するための戦略に関するものです。Participantが休会または退会状態になった場合に、Teamからも離脱する必要があり、この操作をどう扱うべきかという問題です。

DDD（ドメイン駆動設計）の原則では、理想的には各集約は独立したトランザクション境界を持つべきですが、現実の実装ではトレードオフが発生します。この状況を分析しましょう。

考慮すべき点:
1. 原則論としての「集約ごとに独立したトランザクション」
2. 現実的な「不変条件と整合性の維持」
3. ユースケースの重要性（休会・退会が業務上即時に反映されるべきか）
4. 実装の複雑さとリスク

回答では、いくつかのアプローチとそれぞれのトレードオフを説明し、状況に応じた選択肢を提供したいと思います。</think># 休会・退会時のTeam関係処理について

ご質問の「Participantが休会または退会になった際のチームからの離脱処理」は、ドメインモデリングにおける重要な設計判断ポイントです。

## 理想的なDDDアプローチと現実的な実装

### 理想的なDDDの原則
厳密なDDDの原則に従うと、**異なる集約は別々のトランザクションで更新されるべき**です。これにより:
- 集約の独立性と一貫性が保たれる
- スケーラビリティが向上する
- 結合度が低下する

### 現実的な実装オプション

#### 1. 複数トランザクション + 結果整合性アプローチ
```
// 疑似コード - 結果整合性を許容した実装
transaction1 {
  participant = participantRepository.findById(id);
  participant.changeStatus(EnrollmentStatus.INACTIVE); // 休会に変更
  participantRepository.save(participant);
  
  // イベント発行
  eventBus.publish(new ParticipantStatusChanged(participant.id, EnrollmentStatus.INACTIVE));
}

// 別プロセス/スレッドで
onParticipantStatusChanged(event) {
  transaction2 {
    if (event.newStatus == EnrollmentStatus.INACTIVE || event.newStatus == EnrollmentStatus.WITHDRAWN) {
      team = teamRepository.findTeamByMemberId(event.participantId);
      if (team != null) {
        team.removeMember(event.participantId);
        team.handleMemberReduction(); // チームサイズが2人未満になった場合の処理
        teamRepository.save(team);
      }
    }
  }
}
```

#### 2. 単一トランザクションアプローチ
```
// 疑似コード - 単一トランザクションでの実装
transaction {
  // 1. 参加者のステータス変更
  participant = participantRepository.findById(id);
  participant.changeStatus(EnrollmentStatus.INACTIVE); // 休会に変更
  
  // 2. チームからの離脱処理
  team = teamRepository.findTeamByMemberId(participant.id);
  if (team != null) {
    team.removeMember(participant.id);
    team.handleMemberReduction(); // チームサイズが2人未満になった場合の処理
    
    teamRepository.save(team);
  }
  
  participantRepository.save(participant);
}
```

## どちらを選ぶべき？

### 単一トランザクションが適している場合:
- このビジネスルールが**即時の一貫性を必要**とする場合
- システムが比較的小規模で分散化されていない場合
- 参加者の休会・退会がチーム構成に即座に影響を与える必要がある場合

### 複数トランザクション/結果整合性が適している場合:
- 大規模/分散システムの場合
- 短時間の不整合状態が許容できる場合
- スケーラビリティが重要な要件である場合
- マイクロサービスアーキテクチャを採用している場合

## 現実的な判断

実務では、**ビジネス要件とシステム特性**に基づいて判断することが重要です:

1. この要件の**ビジネス上の重要度**はどの程度か？
2. 一時的に不整合状態（参加者が休会だがまだチームに所属している状態）が**許容できるか**？
3. システムの**規模と構成**はどうなっているか？

多くの実務プロジェクトでは、開発初期段階では単一トランザクションアプローチを採用し、システムが成長するに従って結果整合性アプローチに移行するという段階的アプローチが効果的です。

どのアプローチを採用するとしても、設計の意図とトレードオフを文書化しておくことをお勧めします。
